import tensorflow as tf
from tensorflow.keras import layers
from tensorflow.keras.models import Model
from emc_pre_engine import EmC_Pre_Generator
from emc_inv_engine import EmC_Inv_Generator

class EmC_Net_Generator:
    def __init__(self,target_dim,control_dim,prediction_dim,
                 env_dim = 0, target_seq_len = None, channel_dim = None,
                 batch_size = None):
        self.control_dim = control_dim
        self.target_dim = target_dim
        if channel_dim is not None:
            assert channel_dim >= control_dim, "total channel number smaller than tunable channel number"
            self.channel_dim = channel_dim
        else:
            self.channel_dim = control_dim
        self.env_dim = env_dim
        
        self.emc_inv_generator = EmC_Inv_Generator(target_dim,control_dim,
                                                   env_dim = env_dim,
                                                   pad_dim = self.channel_dim-self.control_dim,
                                                   seq_len = target_seq_len,
                                                   batch_size = batch_size)
        emc_pre_input_name = ["io1_imp"] if env_dim == 0 else ["io1_imp","io0_env"]
        # The input of this emc_pre is the output of emc_inv, 
        # thus the name of emc_pre_generator.input_name cannot cantain "in" since the first layer is not input layer
        # None model will be returned when create_EmC_Pre is called 
        
        self.emc_pre_generator = EmC_Pre_Generator(self.channel_dim, prediction_dim,
                                                   env_dim = env_dim,
                                                   input_names = emc_pre_input_name)

    def set_inv_rnn(self,layer_num,size,actvfun = "tanh",regu = 0, rnd_init = False):
        self.emc_inv_generator.rnn_paras(layer_num,size,actvfun,regu,rnd_init)
    
    def set_inv_fc(self,layer_num,size,actvfun="relu",limit = True, regu = 0):
        self.emc_inv_generator.fc_paras(layer_num,size,actvfun,limit,regu)
    
    def set_pre_conv(self,layer_num,cluster,channel,actvfun="relu",regu = 0,env_on_all_conv = False):
        self.emc_pre_generator.conv_paras(layer_num,cluster,channel,actvfun,regu,env_on_all_conv)
    
    def set_pre_fc(self,layer_num,size,actvfun="relu", regu = 0):
        self.emc_pre_generator.fc_paras(layer_num,size,actvfun,regu)
        
    def hyperpara_summary(self):
        return str(self.emc_pre_generator)+str(self.emc_inv_generator)
    def __str__(self):
        return self.hyperpara_summary()
    
    def create_EmC_Net(self):
        model_inv = self.emc_inv_generator.create_EmC_Inv()
        interconnect = model_inv.outputs[0]
        if self.env_dim > 0:
            (_, output_ptrn) = self.emc_pre_generator.create_EmC_Pre(prelayer = interconnect,
                                                                     envlayer = model_inv.inputs[1])
        else:
            (_, output_ptrn) = self.emc_pre_generator.create_EmC_Pre(prelayer = interconnect)
            
        model_net = Model(inputs = model_inv.inputs, outputs = output_ptrn)
        return (model_inv,model_net)
    
    def load_pre_net(self,emc_net_model,pre_net_dir,lock_pre_weights = True,verbose = True):
        # emc_net_model should generated by self so that the parameters are matched
        self.emc_pre_generator.load_net(emc_net_model,pre_net_dir,lock_pre_weights,verbose)
    
    def create_EmC_Net_with(self,emc_net_dir):
        (model_inv,model_net) = self.create_EmC_Net()
        model_net.load_weights(emc_net_dir,by_name = True)
        print("Network weights loaded.")
        return (model_inv,model_net)